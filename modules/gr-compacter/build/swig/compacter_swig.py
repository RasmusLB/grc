# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_compacter_swig')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_compacter_swig')
    _compacter_swig = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_compacter_swig', [dirname(__file__)])
        except ImportError:
            import _compacter_swig
            return _compacter_swig
        try:
            _mod = imp.load_module('_compacter_swig', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _compacter_swig = swig_import_helper()
    del swig_import_helper
else:
    import _compacter_swig
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def high_res_timer_now():
    """high_res_timer_now() -> gr::high_res_timer_type"""
    return _compacter_swig.high_res_timer_now()

def high_res_timer_now_perfmon():
    """high_res_timer_now_perfmon() -> gr::high_res_timer_type"""
    return _compacter_swig.high_res_timer_now_perfmon()

def high_res_timer_tps():
    """high_res_timer_tps() -> gr::high_res_timer_type"""
    return _compacter_swig.high_res_timer_tps()

def high_res_timer_epoch():
    """high_res_timer_epoch() -> gr::high_res_timer_type"""
    return _compacter_swig.high_res_timer_epoch()
class compact_file_sink(object):
    """
    The compactor is a module created for the purpose of logging power spectrum measurement to a file in a way that minimizes storage usage by exluding certain values.

    Constructor Specific Documentation:

    Return a shared_ptr to a new instance of compacter::compact_file_sink.

    To avoid accidental use of raw pointers, compacter::compact_file_sink's constructor is in a private implementation class. compacter::compact_file_sink::make is the public interface for creating new instances.

    Args:
        filename : name of the file to open and write output to.
        append : if true, data is appended to the file instead of overwriting the initial content.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def make(itemsize, filename, append=False):
        """
        make(size_t itemsize, char const * filename, bool append=False) -> compact_file_sink_sptr

        The compactor is a module created for the purpose of logging power spectrum measurement to a file in a way that minimizes storage usage by exluding certain values.

        Constructor Specific Documentation:

        Return a shared_ptr to a new instance of compacter::compact_file_sink.

        To avoid accidental use of raw pointers, compacter::compact_file_sink's constructor is in a private implementation class. compacter::compact_file_sink::make is the public interface for creating new instances.

        Args:
            filename : name of the file to open and write output to.
            append : if true, data is appended to the file instead of overwriting the initial content.
        """
        return _compacter_swig.compact_file_sink_make(itemsize, filename, append)

    make = staticmethod(make)

    def set_sample_rate(self, sample_rate):
        """
        set_sample_rate(compact_file_sink self, uint64_t sample_rate)

        Set the sample rate.

        The sample rate is saved in the file for future use in processing. The sample rate is written to the file before the first measurement is recorded. Therefore, the changing the sample rate will only have effect, when it is done before the file is created. The sample rate is not directly utilized by the module, but for processing purposes, the sample rate should reflect the actual sampling rate used in the system
        """
        return _compacter_swig.compact_file_sink_set_sample_rate(self, sample_rate)


    def sample_rate(self):
        """
        sample_rate(compact_file_sink self) -> uint64_t

        Returns the sample rate.

        The sample rate
        """
        return _compacter_swig.compact_file_sink_sample_rate(self)


    def set_fft_size(self, fft_size):
        """
        set_fft_size(compact_file_sink self, uint32_t fft_size)

        Set the fft size.

        The fft size is saved in the file for future use in processing and used for compacting. The format of the compacted file is dependent on the fft size, thus the value should only be changed before the file has been created.
        """
        return _compacter_swig.compact_file_sink_set_fft_size(self, fft_size)


    def fft_size(self):
        """fft_size(compact_file_sink self) -> uint32_t"""
        return _compacter_swig.compact_file_sink_fft_size(self)


    def set_center_freq(self, center_freq):
        """
        set_center_freq(compact_file_sink self, uint64_t center_freq)

        Set the center frequency.

        The center frequency is saved in the file for future use in processing. The center frequency is written to the file before the first measurement is recorded. Therefore, changing the center frequency will only have effect, when it is done before the file is created. The center frequency is not directly utilized by the module, but for processing purposes, the center frequency should reflect the actual center frequency used in the system
        """
        return _compacter_swig.compact_file_sink_set_center_freq(self, center_freq)


    def center_freq(self):
        """center_freq(compact_file_sink self) -> uint64_t"""
        return _compacter_swig.compact_file_sink_center_freq(self)


    def set_compact_threshold(self, compact_threshold):
        """
        set_compact_threshold(compact_file_sink self, float compact_threshold)

        Set the filtering threshold.

        The filtering threshold determines which power measurements should be stored. Any values below the threshold are discarded. This is intended to allow disregarding power measurements that fall below the noise floor, and therefore bears no relevant information. The value of the power being filtered is in dB, and dBm if the device is calibrated.
        """
        return _compacter_swig.compact_file_sink_set_compact_threshold(self, compact_threshold)


    def compact_threshold(self):
        """compact_threshold(compact_file_sink self) -> float"""
        return _compacter_swig.compact_file_sink_compact_threshold(self)


    def set_unbuffered(self, unbuffered):
        """
        set_unbuffered(compact_file_sink self, bool unbuffered)

        Disallow buffereing of the value to file.

        Since writing to a file has interaction the the parmanent storage on the device. The operating system will by default buffer data for effecient I/O operations Setting unbuffered, enforces the flushing of the file write buffer, after each input cycle.
        """
        return _compacter_swig.compact_file_sink_set_unbuffered(self, unbuffered)

    __swig_destroy__ = _compacter_swig.delete_compact_file_sink
    __del__ = lambda self: None
compact_file_sink_swigregister = _compacter_swig.compact_file_sink_swigregister
compact_file_sink_swigregister(compact_file_sink)

def compact_file_sink_make(itemsize, filename, append=False):
    """
    compact_file_sink_make(size_t itemsize, char const * filename, bool append=False) -> compact_file_sink_sptr

    The compactor is a module created for the purpose of logging power spectrum measurement to a file in a way that minimizes storage usage by exluding certain values.

    Constructor Specific Documentation:

    Return a shared_ptr to a new instance of compacter::compact_file_sink.

    To avoid accidental use of raw pointers, compacter::compact_file_sink's constructor is in a private implementation class. compacter::compact_file_sink::make is the public interface for creating new instances.

    Args:
        filename : name of the file to open and write output to.
        append : if true, data is appended to the file instead of overwriting the initial content.
    """
    return _compacter_swig.compact_file_sink_make(itemsize, filename, append)

class compact_file_sink_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::compacter::compact_file_sink)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::compacter::compact_file_sink)> self) -> compact_file_sink_sptr
        __init__(boost::shared_ptr<(gr::compacter::compact_file_sink)> self, compact_file_sink p) -> compact_file_sink_sptr
        """
        this = _compacter_swig.new_compact_file_sink_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(compact_file_sink_sptr self) -> compact_file_sink"""
        return _compacter_swig.compact_file_sink_sptr___deref__(self)

    __swig_destroy__ = _compacter_swig.delete_compact_file_sink_sptr
    __del__ = lambda self: None

    def make(self, itemsize, filename, append=False):
        """
        make(compact_file_sink_sptr self, size_t itemsize, char const * filename, bool append=False) -> compact_file_sink_sptr

        The compactor is a module created for the purpose of logging power spectrum measurement to a file in a way that minimizes storage usage by exluding certain values.

        Constructor Specific Documentation:

        Return a shared_ptr to a new instance of compacter::compact_file_sink.

        To avoid accidental use of raw pointers, compacter::compact_file_sink's constructor is in a private implementation class. compacter::compact_file_sink::make is the public interface for creating new instances.

        Args:
            filename : name of the file to open and write output to.
            append : if true, data is appended to the file instead of overwriting the initial content.
        """
        return _compacter_swig.compact_file_sink_sptr_make(self, itemsize, filename, append)


    def set_sample_rate(self, sample_rate):
        """
        set_sample_rate(compact_file_sink_sptr self, uint64_t sample_rate)

        Set the sample rate.

        The sample rate is saved in the file for future use in processing. The sample rate is written to the file before the first measurement is recorded. Therefore, the changing the sample rate will only have effect, when it is done before the file is created. The sample rate is not directly utilized by the module, but for processing purposes, the sample rate should reflect the actual sampling rate used in the system
        """
        return _compacter_swig.compact_file_sink_sptr_set_sample_rate(self, sample_rate)


    def sample_rate(self):
        """
        sample_rate(compact_file_sink_sptr self) -> uint64_t

        Returns the sample rate.

        The sample rate
        """
        return _compacter_swig.compact_file_sink_sptr_sample_rate(self)


    def set_fft_size(self, fft_size):
        """
        set_fft_size(compact_file_sink_sptr self, uint32_t fft_size)

        Set the fft size.

        The fft size is saved in the file for future use in processing and used for compacting. The format of the compacted file is dependent on the fft size, thus the value should only be changed before the file has been created.
        """
        return _compacter_swig.compact_file_sink_sptr_set_fft_size(self, fft_size)


    def fft_size(self):
        """fft_size(compact_file_sink_sptr self) -> uint32_t"""
        return _compacter_swig.compact_file_sink_sptr_fft_size(self)


    def set_center_freq(self, center_freq):
        """
        set_center_freq(compact_file_sink_sptr self, uint64_t center_freq)

        Set the center frequency.

        The center frequency is saved in the file for future use in processing. The center frequency is written to the file before the first measurement is recorded. Therefore, changing the center frequency will only have effect, when it is done before the file is created. The center frequency is not directly utilized by the module, but for processing purposes, the center frequency should reflect the actual center frequency used in the system
        """
        return _compacter_swig.compact_file_sink_sptr_set_center_freq(self, center_freq)


    def center_freq(self):
        """center_freq(compact_file_sink_sptr self) -> uint64_t"""
        return _compacter_swig.compact_file_sink_sptr_center_freq(self)


    def set_compact_threshold(self, compact_threshold):
        """
        set_compact_threshold(compact_file_sink_sptr self, float compact_threshold)

        Set the filtering threshold.

        The filtering threshold determines which power measurements should be stored. Any values below the threshold are discarded. This is intended to allow disregarding power measurements that fall below the noise floor, and therefore bears no relevant information. The value of the power being filtered is in dB, and dBm if the device is calibrated.
        """
        return _compacter_swig.compact_file_sink_sptr_set_compact_threshold(self, compact_threshold)


    def compact_threshold(self):
        """compact_threshold(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_compact_threshold(self)


    def set_unbuffered(self, unbuffered):
        """
        set_unbuffered(compact_file_sink_sptr self, bool unbuffered)

        Disallow buffereing of the value to file.

        Since writing to a file has interaction the the parmanent storage on the device. The operating system will by default buffer data for effecient I/O operations Setting unbuffered, enforces the flushing of the file write buffer, after each input cycle.
        """
        return _compacter_swig.compact_file_sink_sptr_set_unbuffered(self, unbuffered)


    def history(self):
        """history(compact_file_sink_sptr self) -> unsigned int"""
        return _compacter_swig.compact_file_sink_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(compact_file_sink_sptr self, int which, int delay)
        declare_sample_delay(compact_file_sink_sptr self, unsigned int delay)
        """
        return _compacter_swig.compact_file_sink_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(compact_file_sink_sptr self, int which) -> unsigned int"""
        return _compacter_swig.compact_file_sink_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(compact_file_sink_sptr self) -> int"""
        return _compacter_swig.compact_file_sink_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(compact_file_sink_sptr self) -> double"""
        return _compacter_swig.compact_file_sink_sptr_relative_rate(self)


    def start(self):
        """start(compact_file_sink_sptr self) -> bool"""
        return _compacter_swig.compact_file_sink_sptr_start(self)


    def stop(self):
        """stop(compact_file_sink_sptr self) -> bool"""
        return _compacter_swig.compact_file_sink_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(compact_file_sink_sptr self, unsigned int which_input) -> uint64_t"""
        return _compacter_swig.compact_file_sink_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(compact_file_sink_sptr self, unsigned int which_output) -> uint64_t"""
        return _compacter_swig.compact_file_sink_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(compact_file_sink_sptr self) -> int"""
        return _compacter_swig.compact_file_sink_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(compact_file_sink_sptr self, int m)"""
        return _compacter_swig.compact_file_sink_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(compact_file_sink_sptr self)"""
        return _compacter_swig.compact_file_sink_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(compact_file_sink_sptr self) -> bool"""
        return _compacter_swig.compact_file_sink_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(compact_file_sink_sptr self, int m)"""
        return _compacter_swig.compact_file_sink_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(compact_file_sink_sptr self) -> int"""
        return _compacter_swig.compact_file_sink_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(compact_file_sink_sptr self, int i) -> long"""
        return _compacter_swig.compact_file_sink_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(compact_file_sink_sptr self, long max_output_buffer)
        set_max_output_buffer(compact_file_sink_sptr self, int port, long max_output_buffer)
        """
        return _compacter_swig.compact_file_sink_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(compact_file_sink_sptr self, int i) -> long"""
        return _compacter_swig.compact_file_sink_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(compact_file_sink_sptr self, long min_output_buffer)
        set_min_output_buffer(compact_file_sink_sptr self, int port, long min_output_buffer)
        """
        return _compacter_swig.compact_file_sink_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(compact_file_sink_sptr self, int which) -> float
        pc_input_buffers_full(compact_file_sink_sptr self) -> pmt_vector_float
        """
        return _compacter_swig.compact_file_sink_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(compact_file_sink_sptr self, int which) -> float
        pc_input_buffers_full_avg(compact_file_sink_sptr self) -> pmt_vector_float
        """
        return _compacter_swig.compact_file_sink_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(compact_file_sink_sptr self, int which) -> float
        pc_input_buffers_full_var(compact_file_sink_sptr self) -> pmt_vector_float
        """
        return _compacter_swig.compact_file_sink_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(compact_file_sink_sptr self, int which) -> float
        pc_output_buffers_full(compact_file_sink_sptr self) -> pmt_vector_float
        """
        return _compacter_swig.compact_file_sink_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(compact_file_sink_sptr self, int which) -> float
        pc_output_buffers_full_avg(compact_file_sink_sptr self) -> pmt_vector_float
        """
        return _compacter_swig.compact_file_sink_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(compact_file_sink_sptr self, int which) -> float
        pc_output_buffers_full_var(compact_file_sink_sptr self) -> pmt_vector_float
        """
        return _compacter_swig.compact_file_sink_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(compact_file_sink_sptr self) -> float"""
        return _compacter_swig.compact_file_sink_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(compact_file_sink_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _compacter_swig.compact_file_sink_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(compact_file_sink_sptr self)"""
        return _compacter_swig.compact_file_sink_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(compact_file_sink_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _compacter_swig.compact_file_sink_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(compact_file_sink_sptr self) -> int"""
        return _compacter_swig.compact_file_sink_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(compact_file_sink_sptr self) -> int"""
        return _compacter_swig.compact_file_sink_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(compact_file_sink_sptr self, int priority) -> int"""
        return _compacter_swig.compact_file_sink_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(compact_file_sink_sptr self) -> std::string"""
        return _compacter_swig.compact_file_sink_sptr_name(self)


    def symbol_name(self):
        """symbol_name(compact_file_sink_sptr self) -> std::string"""
        return _compacter_swig.compact_file_sink_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(compact_file_sink_sptr self) -> io_signature_sptr"""
        return _compacter_swig.compact_file_sink_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(compact_file_sink_sptr self) -> io_signature_sptr"""
        return _compacter_swig.compact_file_sink_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(compact_file_sink_sptr self) -> long"""
        return _compacter_swig.compact_file_sink_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(compact_file_sink_sptr self) -> basic_block_sptr"""
        return _compacter_swig.compact_file_sink_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(compact_file_sink_sptr self, int ninputs, int noutputs) -> bool"""
        return _compacter_swig.compact_file_sink_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(compact_file_sink_sptr self) -> std::string"""
        return _compacter_swig.compact_file_sink_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(compact_file_sink_sptr self, std::string name)"""
        return _compacter_swig.compact_file_sink_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(compact_file_sink_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _compacter_swig.compact_file_sink_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(compact_file_sink_sptr self) -> swig_int_ptr"""
        return _compacter_swig.compact_file_sink_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(compact_file_sink_sptr self) -> swig_int_ptr"""
        return _compacter_swig.compact_file_sink_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(compact_file_sink_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _compacter_swig.compact_file_sink_sptr_message_subscribers(self, which_port)

compact_file_sink_sptr_swigregister = _compacter_swig.compact_file_sink_sptr_swigregister
compact_file_sink_sptr_swigregister(compact_file_sink_sptr)


compact_file_sink_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
compact_file_sink = compact_file_sink.make;



